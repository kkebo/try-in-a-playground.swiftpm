import Foundation
import Version

enum PlaygroundGeneratorError: Error {
    case unexpectedScheme(String)
    case unknownAction(String)
    case invalidURL(URL)
    case missingDependenciesQuery
    case notYetReleased
    case nonUTF8Manifest
}

extension PlaygroundGeneratorError: CustomStringConvertible {
    var description: String {
        switch self {
        case .unexpectedScheme(let scheme): "The scheme \"\(scheme)\" is unexpected."
        case .unknownAction(let action): "The action \"\(action)\" is not supported."
        case .invalidURL(let url): "\(url) is invalid."
        case .missingDependenciesQuery: "The query \"dependencies\" is missing."
        case .notYetReleased: "The package is not yet released."
        case .nonUTF8Manifest: "Package.swift is not UTF-8."
        }
    }
}

struct PlaygroundGenerator {
    let packageName: String
    let libraryNames: [String]
    let packageURL: URL
    let latestVersion: String

    init(url: URL) async throws {
        guard let scheme = url.scheme, let host = url.host() else {
            throw PlaygroundGeneratorError.invalidURL(url)
        }
        guard scheme == "spi-playgrounds" else {
            throw PlaygroundGeneratorError.unexpectedScheme(scheme)
        }
        guard host == "open" else { throw PlaygroundGeneratorError.unknownAction(host) }
        guard let components = URLComponents(url: url, resolvingAgainstBaseURL: false) else {
            throw PlaygroundGeneratorError.invalidURL(url)
        }
        guard let repoID = components.queryItems?.first(where: { $0.name == "dependencies" })?.value else {
            throw PlaygroundGeneratorError.missingDependenciesQuery
        }
        guard let packageName = repoID.split(separator: "/").last.map(String.init) else {
            preconditionFailure("unreachable")
        }
        let packageURL = githubBaseURL.appending(path: repoID)
        let tagsURL = githubAPIBaseURL.appending(path: "repos/\(repoID)/git/matching-refs/tags")
        let (tagsData, _) = try await URLSession.shared.data(from: tagsURL)
        let tag = try JSONDecoder().decode(GitReferences.self, from: tagsData).lazy
            .map(\.ref)
            .map { $0.trimmingPrefix("refs/tags/") }
            .compactMap { Version(tolerant: $0) }
            .filter { $0.prereleaseIdentifiers.isEmpty }
            .max()
        guard let tag else { throw PlaygroundGeneratorError.notYetReleased }
        let manifestURL = githubRawBaseURL.appending(path: "\(repoID)/refs/tags/\(tag)/Package.swift")
        let (manifestData, _) = try await URLSession.shared.data(from: manifestURL)
        guard let manifest = String(data: manifestData, encoding: .utf8) else {
            throw PlaygroundGeneratorError.nonUTF8Manifest
        }
        let libraryNames: [String] =
            manifest.matches(of: /\.library\(\s*name:\s*"(?<name>[^"]+)"/).lazy
            .map(\.output.name)
            .map(String.init)

        self.packageName = packageName
        self.packageURL = packageURL
        self.latestVersion = tag.description
        self.libraryNames = libraryNames
    }

    func generate() throws -> URL {
        let products = self.libraryNames.lazy
            .map { "                .product(name: \"\($0)\", package: \"\(self.packageName)\")" }
            .joined(separator: ",\n")
        let imports = self.libraryNames.lazy
            .map { "import \($0)" }
            .joined(separator: "\n")
        let manifest = """
            // swift-tools-version: 6.0

            // WARNING:
            // This file is automatically generated.
            // Do not edit it by hand because the contents will be replaced.

            import PackageDescription
            import AppleProductTypes

            let package = Package(
                name: "My App",
                platforms: [
                    .iOS("18.1")
                ],
                products: [
                    .iOSApplication(
                        name: "My App",
                        targets: ["AppModule"],
                        displayVersion: "1.0",
                        bundleVersion: "1",
                        appIcon: .placeholder(icon: .box),
                        accentColor: .presetColor(.blue),
                        supportedDeviceFamilies: [
                            .pad,
                            .phone
                        ],
                        supportedInterfaceOrientations: [
                            .portrait,
                            .landscapeRight,
                            .landscapeLeft,
                            .portraitUpsideDown(.when(deviceFamilies: [.pad]))
                        ]
                    )
                ],
                dependencies: [
                    .package(url: "\(self.packageURL)", from: "\(self.latestVersion)")
                ],
                targets: [
                    .executableTarget(
                        name: "AppModule",
                        dependencies: [
            \(products)
                        ],
                        path: "."
                    )
                ]
            )
            """
        let myApp = """
            import SwiftUI

            @main
            struct MyApp: App {
                var body: some Scene {
                    WindowGroup {
                        ContentView()
                    }
                }
            }
            """
        let contentView = """
            import SwiftUI
            \(imports)

            struct ContentView: View {
                var body: some View {
                    Text("Hello, world!")
                }
            }
            """
        let fm = FileManager.default
        let tmp = URL.temporaryDirectory
        let packageURL = tmp.appending(path: "My App.swiftpm")
        if fm.fileExists(atPath: packageURL.path(percentEncoded: false)) {
            try fm.removeItem(at: packageURL)
        }
        try fm.createDirectory(
            at: packageURL,
            withIntermediateDirectories: false
        )
        try manifest.write(
            to: packageURL.appending(path: "Package.swift"),
            atomically: true,
            encoding: .utf8
        )
        try myApp.write(
            to: packageURL.appending(path: "MyApp.swift"),
            atomically: true,
            encoding: .utf8
        )
        try contentView.write(
            to: packageURL.appending(path: "ContentView.swift"),
            atomically: true,
            encoding: .utf8
        )
        return packageURL
    }
}
